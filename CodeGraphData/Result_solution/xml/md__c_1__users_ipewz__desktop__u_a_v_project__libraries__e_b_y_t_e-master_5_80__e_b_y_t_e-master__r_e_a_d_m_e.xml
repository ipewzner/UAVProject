<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="md__c_1__users_ipewz__desktop__u_a_v_project__libraries__e_b_y_t_e-master_5_80__e_b_y_t_e-master__r_e_a_d_m_e" kind="page">
    <compoundname>md_C:_Users_ipewz_Desktop_UAVProject_Libraries_EBYTE-master_5.0_EBYTE-master_README</compoundname>
    <title>EBYTE</title>
    <detaileddescription>
<para><bold><heading level="2"><center>Updates </center> 3/20/2021, added ESP8266 and ESP32 examples 7/19/2021, increased pin reaction time to 50 ms to address parameter reading issues </heading>
</bold></para><para><bold></bold> <linebreak/>
 <bold><heading level="2"><center><ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> Transceivers</center></heading>
</bold></para><para><bold></bold></para><para>This library is intended to be used with UART type <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> transceivers (E44-TTL-100 for example), small wireless units for MCU&apos;s such as Teensy and Arduino. This library lets users program the operating parameters and both send and receive data. This company makes several modules with different capabilities, but most #defines here should be compatible with them All constants were extracted from several data sheets and listed in binary as that&apos;s how the data sheet represented each setting. Hopefully, any changes or additions to constants can be a matter of copying the data sheet constants directly into the #defines. Usage of this library consumes around 970 bytes.</para><para>You only really need this library to program these <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> units. For reading data structures, you can call readBytes directly on the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> Serial object</para><para>ESerial.readBytes((uint8_t*)&amp; MyData, (uint8_t) sizeof(MyData));</para><para>for writing data structures you can call write directly on the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> Serial object</para><para>ESerial.write((uint8_t*) &amp;Data, PacketSize );</para><para><bold> <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> Model numbers (only a partial list shown)</bold> Old model number scheme E30-TTL-100,E30-490T20D, E31-TTL-100, E32-TTL-100, E32-TTL-500, E32-TTL-1W, E41-TTL-100, E41-TTL-100, E44-TTL-100, E44-TTL-500, E44-TTL-1W, E50-TTL-100, E50-TTL-500, E51-TTL-100, E51-TTL-500, E51-TTL-1W</para><para>New model number scheme E22-900T22S, E22-230T22S, E22-400T22S, E22-230T30S, E22-400T30S, E22-900T30S, E30-433T20S3, E30-170T20D, E30-170T27D, E30-780T20S, E30-868T20S, E30-868T20D, E30-915T20D, E30-490T20D, E30-433T20S, E30-433T20D, E30-915T20S, E30-490T20S, E31-433T30S, E31-433T17S3, E31-230T33D, E31-230T17D, E31-230T27D, E31-433T17S, E31-433T17D, E31-433T27D, E31-433T30D, E31-433T33D, E32-433T20DC, E32-433T20S, E32-433T20S2T, E32-433T27D, E32-433T30D, E32-433T30S, E32-868T20D, E32-868T20S, E32-868T30D, E32-868T30S, E32-915T20D, E32-915T20S, E32-915T30D, E32-915T30S, E32-170T30D, E32-400T20S</para><para>Note: check the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> website to make sure the selected module supports UART communications, some modules are SPI only.</para><para>Here is a YouTube video on library usage: <ulink url="https://youtu.be/hMjArKGucFA">https://youtu.be/hMjArKGucFA</ulink></para><para><bold><heading level="3">Module connection </heading>
</bold></para><para><bold> Module MCU Description<orderedlist>
<listitem><para>MO Any digital pin* pin to control working/program modes</para></listitem><listitem><para>M1 Any digital pin* pin to control working/program modes</para></listitem><listitem><para>Rx Any digital pin* pin to MCU TX pin (module transmits to MCU, hence MCU must receive data from module</para></listitem><listitem><para>Tx Any digital pin* pin to MCU RX pin (module transmits to MCU, hence MCU must receive data from module</para></listitem><listitem><para>AUX Any digital pin pin to indicate when an operation is complete (low is busy, high is done) (you can omit with -1, but fixed recovery time used and may not be long enough to complete the operation)</para></listitem><listitem><para>Vcc +3v3 or 5V0, note the units may run warmer with 5V0 and consume more power</para></listitem><listitem><para>Vcc Ground Ground must be common to module and MCU</para></listitem></orderedlist>
</bold></para><para><bold>notes</bold></para><para><bold><orderedlist>
<listitem><para>caution in connecting to Arduino pin 0 and 1 as those pins are for USB connection to PC so you can&apos;t have the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> connected during programming. I recommend NOT using Arduino pins 0 and 1</para></listitem><listitem><para>The signal lines for these units are 3V3 but are 5 volt tolerant, however 5 volts may result in communication failures. If using a 5 volt MCU such as arduino, you may need to do the following. a) You may need a 4K7-10K pullup to Rx and AUX pins (possibly Tx) if using and Arduino b) If using an Arduino you may need a series 4K7 resistor between MCU Tx and the transceiver Rx.</para></listitem><listitem><para>In some of my applications, I did not have enough digital pins to connect the Aux pin. No worries (just pass -1 in the argument list in the object create code). Then you will need to provide an appropriate delay() to let the transmission complete<ndash/>experiment with the amount.</para></listitem><listitem><para>Serial pins for connection is dependent on the MCU, Teensy 3.2 for example: Serial1 are Rx=0, Rx=0, Serial2 Rx=9, Tx=10, Serial3 Rx=7, Tx=8. Arduino can be most serial pins using <ref refid="class_software_serial" kindref="compound">SoftwareSerial(MCU_Rx_pin, MCU_Tx_pin)</ref>, except pins 0 and 1 as those are for USB usage</para></listitem><listitem><para>Some MCU such as the Teensy, and ESP32 do NOT allow the use of <ref refid="class_software_serial" kindref="compound">SoftwareSerial</ref> to create a communications port. No worries, just hard wire the EBTYE to a dedicated UART port (pin 0 and pin 1 on a teensy 3.2 for Serial1.</para></listitem></orderedlist>
</bold></para><para><bold><bold><heading level="3">Manufacturers website</heading>
</bold></bold></para><para><bold><bold> <ulink url="http://www.ebyte.com/en/">http://www.ebyte.com/en/</ulink> example module this library is intended to be used with <ulink url="http://www.ebyte.com/en/product-view-news.aspx?id=174">http://www.ebyte.com/en/product-view-news.aspx?id=174</ulink></bold></bold></para><para><bold><bold><bold><heading level="3">General code usage</heading>
</bold></bold></bold></para><para><bold><bold><bold><orderedlist>
<listitem><para>Create a serial object</para></listitem><listitem><para>Create <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> object that uses the serial object</para></listitem><listitem><para>begin the serial object</para></listitem><listitem><para>init() the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> object</para></listitem><listitem><para>set parameters (optional but required if sender and receiver are different)</para></listitem><listitem><para>send or listen to sent data (single byte) OR create and send a data structure</para></listitem></orderedlist>
</bold></bold></bold></para><para><bold><bold><bold><bold><heading level="3">Tips on usage</heading>
</bold></bold></bold></bold></para><para><bold><bold><bold><bold></bold></bold></bold></bold></para><para><bold><bold><bold><bold>For best range: <itemizedlist>
<listitem>
<para>Data sheet indicates best results are with antennas 2meters off of ground </para></listitem>
<listitem>
<para>Line of sight ideal, but my personal testing, transmission still successful with some obstructions </para></listitem>
<listitem>
<para>Slow air data rates can improve range, but due to longer transmission time, how often data can be sent will be sacrificed </para></listitem>
<listitem>
<para>Consider high gain antennas (can be purchased from the manufacturer) see their web site for details </para></listitem>
<listitem>
<para>The data sheet says for max range, power the units with 5.0 volts (keep 3V3 on the signal lines). I personaly found little range differene with higher supply voltage </para></listitem>
<listitem>
<para>The data sheet says for max range, set the air data rate to 2.4 bps. I personaly found little range differene with low data rates, and low data rates may limit how often you can send data. </para><para></para></listitem>
</itemizedlist>
</bold></bold></bold></bold></para><para><bold><bold><bold><bold><bold><heading level="3">Data transmission packets</heading>
</bold></bold></bold></bold></bold></para><para><bold><bold><bold><bold><bold> <itemizedlist>
<listitem>
<para>this library has a method for sending single bytes but if more data is to be sent, create a data structure and send the data structure using the librarys SendStruct(&amp;struct, sizeof(struct)) method. Note pass by ref so include the &amp; before structure name </para></listitem>
<listitem>
<para>again slow data rates take longer, you will need to experiment with ideal air data rate range based on data size </para></listitem>
<listitem>
<para>if you need to send data using a struct between different MCU&apos;s changes of how each processor packs will probably be different. If you get corrupted data on the recieving end, there are ways to force the compiler to not optimize struct packing<ndash/>i&apos;ve yet to get them to work. What worked for me is to use a library that creates the strut and handles sending. Check out EasyTransfer.h (google it and get your favorite author). In these libs you will use their method of sending and getting struct (there are hardware and software libs, use accordingly. Meaning you can use this library to program and manage settings but use EasyTransfer to handle sending data throught the serial lines the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> is using. Sounds weird, but it&apos;s no differnet that say Serial1.sendBytes(...) as that is actually what this library is calling. Maybe some day i&apos;ll integrate EasyTranfer technology into this sendstruct lib. </para></listitem>
</itemizedlist>
<bold><heading level="3">Debugging</heading>
</bold></bold></bold></bold></bold></bold></para><para><bold><bold><bold><bold><bold><bold> <itemizedlist>
<listitem>
<para><bold>If your wireless module is returning all 0&apos;s for the PrintParameters() method, make sure your wiring is correct and working, MCU Rx needs to connecte to the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> Tx and vice versa. Also make sure M0, M0, and AUX are connected to valid digital ports. Most issues are due to incorrect data line connections </bold> </para></listitem>
<listitem>
<para><bold>If your wireless module is returning all 0&apos;s for the PrintParameters() method, AND you are sure your wiring is correct, your module may be slow to react to pinMode change performed during a mode change. The datasheet says delay of 2 ms is needed, but I&apos;ve found 10 ms is more reliable. With some units, even more time is needed. The library default is 50 ms, but increase this in the .h file if parameters are not correctly read.</bold> </para></listitem>
<listitem>
<para>If you are using their 1W units, power the unit separately from the MCU&apos;s onboard power supply. The current draw may exceed the onboard rating resulting in destroying the MCU. I have destroyed the onboard voltage regulator on a NANO when trying to power a 1W unit. </para></listitem>
<listitem>
<para>If transmitter and receiver are different MCU (Arduino &lt;-&gt; Teensy), data structures cannot have a mix of data types, due to how an 8-bit processor and 32-bit processor handle ints, floats, etc. If floats and ints are needed to be sent considering multiplying a float to 100 (and recasting to an int), then divide that value by 100 on the receiving end (recasting to a float) </para></listitem>
<listitem>
<para>If you seem to get corrupt data from .PrintParameters, try addinng #include &quot;avr/io.h&quot; to your .INO program </para></listitem>
<listitem>
<para>If using a 5v0 MCU you may need series resistors on the MCU Tx line to the <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> Rx line and possibly the M0 and M1 lines. These <ref refid="class_e_b_y_t_e" kindref="compound">EBYTE</ref> units are supposed to be 5 volt tolerant, but better safe than sorry. Also MFG claims 4K7 pullups can be needed on MCU Tx line and AUX. I have used these transceivers on UNO&apos;s, MEGA&apos;s, and NANO&apos;s w/o any resistors and all was well. I did have one case where a NANO did not work with these transceivers and required some odd powering.</para><para></para></listitem>
</itemizedlist>
</bold></bold></bold></bold></bold></bold></para>    </detaileddescription>
  </compounddef>
</doxygen>
